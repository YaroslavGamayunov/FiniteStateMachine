## Задача
Даны **α** и натуральные числа **k**, **l**, такие что **0 ≤ l < k.** Вывести минимальное
число **n**, равное **l** по модулю **k**, такое что **L** содержит слова длины **n**.

## Решение

Cначала построим на выражении **α** ДКА. После чего воспользуемся методом динамичекского программиования. 

### Динамика
Будем хранить ассоциативный массив **dp \<State, 	Array\<Set\<Int\>\>\>** размера **m x k**, где **m** - количество вершин в ДКА, построенном на выражении **α**. В ячейке **dp[s][i]** будет хранится множество длин строк, которые можно получить проходя по некоторому пути от стартовой вершины ДКА до вершины **s**, таких что их длина сравнима с **i** по модулю **k**. (Поскольку в построенном ДКА все переходы однобуквенные, длина слова - это в точности количество вершин пройденных в автомате при его обработке)

Таким образом, если удастся посчитать такую динамику, достаточно будет пройтись по всем терминальным вершинам, и найти найти минимальную длину среди всех  множеств из **dp[s][l]** - то есть минимальную длину строки, принимаемой автоматом(то есть лежащей в языке **L**) которая **l** по модулю **k**, что и требует задача

Начальное состоние динамики: **dp[startState][0] = {0}** - то есть считаем, что из стартовой вершины автомата возможно получить слово длины **0** по модулю **k**. Для остальных вершин **dp[s][i] = {}**.

Теперь необходимо ввести правило пересчета динамики. Если находясь в вершине **s** мы прочитали строку длины **i**, то если перейти в вершину, смежную с **s**, получим строку длины **i + 1**, поскольку переходы однобуквенные. Значит можно обновить **dp** для всех смежных вершин, зная значение **dp** текущей: получаем такое правило: **i ∈ dp[s][i % k] ⇒ dp[nextS][(i + 1) % k] += {i + 1}**, где nextS - это смежная с s вершина в ДКА. 

Поскольку чтобы получить строку длины **i + 1**, нужно сначала получить строку длины **i**, пересчитывать динамику необходимо в порядке возрастания **i**, проходя по множеству вершин, и применяя правило пересчета. 

Достаточно перебрать **n * v** значений **i**, где **v** - количество вершин в автомате, поскольку на каждом шаге изменяется хотя бы одна ячейка **dp**, за *n * v* шагов либо ячейки перестанут обновляться, либо все заполнятся.   

